SOLID
	is a mnemonic acronym for five design principles intended to make software designs more understandable, flexible and maintainable.
	Single responsibility principle: A class should only have a single responsibility, that is, only changes to one part of the software's 
	specification should be able to affect the specification of the class.
	Open–closed principle: Software entities ... should be open for extension, but closed for modification.
	Liskov substitution principle: Objects in a program should be replaceable with instances of their subtypes without altering the correctness 
	of that program. See also design by contract.
	Interface segregation principle: Many client-specific interfaces are better than one general-purpose interface.
	Dependency inversion principle: One should "depend upon abstractions, [not] concretions."

GoF Design Patterns
	

Good understanding is required:

Factory Patterns

Singleton
	A software design pattern that restricts the instantiation of a class to one "single" instance. This is useful when exactly one object is 
	needed to coordinate actions across the system. The term comes from the mathematical concept of a singleton. The singleton design pattern 
	describes how to solve such problems: Hide the constructor of the class; Define a public static operation (getInstance()) that returns the 
	sole instance of the class. The key idea in this pattern is to make the class itself responsible for controlling its instantiation (that it 
	is instantiated only once). The hidden constructor (declared private) ensures that the class can never be instantiated from outside the class.
	The public static operation can be accessed easily by using the class name and operation name (Singleton.getInstance()).

Adapter Pattern
	A software design pattern (also known as wrapper, an alternative naming shared with the decorator pattern) that allows the interface of an 
	existing class to be used as another interface. It is often used to make existing classes work with others without modifying their source 
	code.
	The adapter design pattern solves problems like: How can a class be reused that does not have an interface that a client requires?; How can 
	classes that have incompatible interfaces work together?; How can an alternative interface be provided for a class?; 
	Often an (already existing) class can't be reused only because its interface doesn't conform to the interface clients require.
	The adapter design pattern describes how to solve such problems: Define a separate adapter class that converts the (incompatible) interface
	of a class (adaptee) into another interface (target) clients require. Work through an adapter to work with (reuse) classes that do not have 
	the required interface. The key idea in this pattern is to work through a separate adapter that adapts the interface of an (already existing) 
	class without changing it.
	Clients don't know whether they work with a target class directly or through an adapter with a class that does not have the target interface.

Composite Pattern
	

Facade Pattern
	

Proxy Pattern
	

The Command Pattern
	

Observer Pattern
	

Strategy Pattern
	

High-level understanding is required:

The Builder Pattern
	

The Prototype Pattern
	

Bridge Pattern
	

Decorator Design Pattern
	

Flyweight
	

Chain of Responsibility
	

Interpreter Pattern
	

Iterator Pattern
	

Mediator Pattern
	

Memento
	

State Pattern
	

Template Method
	

Visitor Pattern
	

Most often used design patterns:

Repository


Service Locator Pattern


Unit of Work


Rules Pattern


Specification Pattern


Event Aggregator


Lazy Load Pattern


Model View Presenter (MVP) Pattern


Model View ViewModel (MVVM) Pattern


Null Object Pattern


Software Architecture Patterns (structure, pros & cons): 

Layered architecture


Event-driven architecture


Microkernel architecture


Microservices architecture


Inversion of Control Containers and the Dependency Injection pattern


Domain-Driven Design patterns:

Why Should You Care About Domain-Driven Design?


Benefits of DDD


Drawbacks of DDD


A Mind Map of DDD's Working Parts



Sub-domain


Bounded Context


Difference Between Sub-domain and Bounded Context


Understanding Context Maps


The Ubiquitous Language of a Bounded Context




Anemic and Rich Models


Entities in DDD and in Our Bounded Context


Value Objects


Domain Services


Aggregates and Aggregate Roots


Repositories


Domain Events


Anti-patterns


