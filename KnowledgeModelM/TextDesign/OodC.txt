SOLID
	is a mnemonic acronym for five design principles intended to make software designs more understandable, flexible and maintainable.
	Single responsibility principle: A class should only have a single responsibility, that is, only changes to one part of the software's 
	specification should be able to affect the specification of the class.
	Open–closed principle: Software entities ... should be open for extension, but closed for modification.
	Liskov substitution principle: Objects in a program should be replaceable with instances of their subtypes without altering the correctness 
	of that program. See also design by contract.
	Interface segregation principle: Many client-specific interfaces are better than one general-purpose interface.
	Dependency inversion principle: One should "depend upon abstractions, [not] concretions."

GoF Design Patterns

Good understanding is required:

Factory Patterns
	

Singleton
	A software design pattern that restricts the instantiation of a class to one "single" instance. This is useful when exactly one object is 
	needed to coordinate actions across the system. The term comes from the mathematical concept of a singleton. The singleton design pattern 
	describes how to solve such problems: Hide the constructor of the class; Define a public static operation (getInstance()) that returns the 
	sole instance of the class. The key idea in this pattern is to make the class itself responsible for controlling its instantiation (that it 
	is instantiated only once). The hidden constructor (declared private) ensures that the class can never be instantiated from outside the class.
	The public static operation can be accessed easily by using the class name and operation name (Singleton.getInstance()).

Adapter Pattern
	A software design pattern (also known as wrapper, an alternative naming shared with the decorator pattern) that allows the interface of an 
	existing class to be used as another interface. It is often used to make existing classes work with others without modifying their source 
	code.
	The adapter design pattern solves problems like: How can a class be reused that does not have an interface that a client requires?; How can 
	classes that have incompatible interfaces work together?; How can an alternative interface be provided for a class?; 
	Often an (already existing) class can't be reused only because its interface doesn't conform to the interface clients require.
	The adapter design pattern describes how to solve such problems: Define a separate adapter class that converts the (incompatible) interface
	of a class (adaptee) into another interface (target) clients require. Work through an adapter to work with (reuse) classes that do not have 
	the required interface. The key idea in this pattern is to work through a separate adapter that adapts the interface of an (already existing) 
	class without changing it.
	Clients don't know whether they work with a target class directly or through an adapter with a class that does not have the target interface.

Composite Pattern
	Is a partitioning design pattern. The composite pattern describes a group of objects that are treated the same way as a single instance of the 
	same type of object. The intent of a composite is to "compose" objects into tree structures to represent part-whole hierarchies. Implementing 
	the composite pattern lets clients treat individual objects and compositions uniformly.
	What problems can the Composite design pattern solve?: A part-whole hierarchy should be represented so that clients can treat part and whole 
	objects uniformly; A part-whole hierarchy should be represented as tree structure; When defining Part objects and Whole objects that act as 
	containers for Part objects, clients must treat them separately, which complicates client code.
	What solution does the Composite design pattern describe? Define a unified Component interface for both part (Leaf) objects and whole (Composite) 
	objects; Individual Leaf objects implement the Component interface directly, and Composite objects forward requests to their child components.
	This enables clients to work through the Component interface to treat Leaf and Composite objects uniformly: Leaf objects perform a request 
	directly, and Composite objects forward the request to their child components recursively downwards the tree structure. This makes client 
	classes easier to implement, change, test, and reuse.

Facade Pattern
	A software-design pattern commonly used in object-oriented programming. Analogous to a facade in architecture, a facade is an object that serves 
	as a front-facing interface masking more complex underlying or structural code. A facade can: improve the readability and usability of a software 
	library by masking interaction with more complex components behind a single (and often simplified) API; provide a context-specific interface to 
	more generic functionality (complete with context-specific input validation); serve as a launching point for a broader refactor of monolithic 
	or tightly-coupled systems in favor of more loosely-coupled code
	Developers often use the facade design pattern when a system is very complex or difficult to understand because the system has many interdependent 
	classes or because its source code is unavailable. This pattern hides the complexities of the larger system and provides a simpler interface to 
	the client. It typically involves a single wrapper class that contains a set of members required by the client. These members access the system 
	on behalf of the facade client and hide the implementation details.
	Define a Facade object that: implements a simple interface in terms of (by delegating to) the interfaces in the subsystem and may perform 
	additional functionality before/after forwarding a request. This enables to work through a Facade object to minimize the dependencies on a 
	subsystem.

Proxy Pattern
	A proxy, in its most general form, is a class functioning as an interface to something else. The proxy could interface to anything: a network 
	connection, a large object in memory, a file, or some other resource that is expensive or impossible to duplicate. In short, a proxy is a 
	wrapper or agent object that is being called by the client to access the real serving object behind the scenes. Use of the proxy can simply 
	be forwarding to the real object, or can provide additional logic. In the proxy, extra functionality can be provided, for example caching 
	when operations on the real object are resource intensive, or checking preconditions before operations on the real object are invoked. For 
	the client, usage of a proxy object is similar to using the real object, because both implement the same interface.
	Define a separate Proxy object that can be used as substitute for another object (Subject) and implements additional functionality to control 
	the access to this subject. This enables to work through a Proxy object to perform additional functionality when accessing a subject. For example, 
	to check the access rights of clients accessing a sensitive object. To act as substitute for a subject, a proxy must implement the Subject 
	interface. Clients can't tell whether they work with a subject or its proxy.

The Command Pattern
	A behavioral design pattern in which an object is used to encapsulate all information needed to perform an action or trigger an event at a later 
	time. This information includes the method name, the object that owns the method and values for the method parameters.
	Four terms always associated with the command pattern are command, receiver, invoker and client. A command object knows about receiver and 
	invokes a method of the receiver. Values for parameters of the receiver method are stored in the command. The receiver object to execute 
	these methods is also stored in the command object by aggregation. The receiver then does the work when the execute() method in command 
	is called. An invoker object knows how to execute a command, and optionally does bookkeeping about the command execution. The invoker does 
	not know anything about a concrete command, it knows only about the command interface. Invoker object(s), command objects and receiver objects 
	are held by a client object, the client decides which receiver objects it assigns to the command objects, and which commands it assigns to the 
	invoker. The client decides which commands to execute at which points. To execute a command, it passes the command object to the invoker object.
	Using command objects makes it easier to construct general components that need to delegate, sequence or execute method calls at a time of 
	their choosing without the need to know the class of the method or the method parameters. Using an invoker object allows bookkeeping about 
	command executions to be conveniently performed, as well as implementing different modes for commands, which are managed by the invoker object, 
	without the need for the client to be aware of the existence of bookkeeping or modes.
	The central ideas of this design pattern closely mirror the semantics of first-class functions and higher-order functions in functional 
	programming languages. Specifically, the invoker object is a higher-order function of which the command object is a first-class argument.

Observer Pattern
	A software design pattern in which an object, called the subject, maintains a list of its dependents, called observers, and notifies them 
	automatically of any state changes, usually by calling one of their methods. It is mainly used to implement distributed event handling 
	systems, in "event driven" software. In those systems, the subject is usually called a "stream of events" or "stream source of events", 
	while the observers are called "sink of events". The stream nomenclature simulates or adapts to a physical setup where the observers are 
	physically separated and have no control over the emitted events of the subject/stream-source. This pattern then perfectly suits any process 
	where data arrives through I/O, that is, where data is not available to the CPU at startup, but can arrive "randomly" (HTTP requests, GPIO 
	data, user input from keyboard/mouse/..., distributed databases and blockchains, ...). Most modern languages have built-in "event" constructs 
	which implement the observer pattern components. While not mandatory most 'observers' implementations will use background threads listening 
	for subject events and other support mechanism from the kernel (Linux epoll, ...)

Strategy Pattern
	A behavioral software design pattern that enables selecting an algorithm at runtime. Instead of implementing a single algorithm directly, code 
	receives run-time instructions as to which in a family of algorithms to use.
	Strategy lets the algorithm vary independently from clients that use it. Strategy is one of the patterns included in the influential book Design 
	Patterns by Gamma et al.[3] that popularized the concept of using design patterns to describe how to design flexible and reusable object-
	oriented software. Deferring the decision about which algorithm to use until runtime allows the calling code to be more flexible and reusable.
	For instance, a class that performs validation on incoming data may use the strategy pattern to select a validation algorithm depending on 
	the type of data, the source of the data, user choice, or other discriminating factors. These factors are not known until run-time and may 
	require radically different validation to be performed. The validation algorithms (strategies), encapsulated separately from the validating 
	object, may be used by other validating objects in different areas of the system (or even different systems) without code duplication.
	Typically the strategy pattern stores a reference to some code in a data structure and retrieves it. This can be achieved by mechanisms such 
	as the native function pointer, the first-class function, classes or class instances in object-oriented programming languages, or accessing 
	the language implementation's internal storage of code via reflection.

High-level understanding is required:

The Builder Pattern
	A design pattern designed to provide a flexible solution to various object creation problems in object-oriented programming. The intent of 
	the Builder design pattern is to separate the construction of a complex object from its representation.
	The Builder design pattern solves problems like:
	How can a class (the same construction process) create different representations of a complex object?
	How can a class that includes creating a complex object be simplified?
	Creating and assembling the parts of a complex object directly within a class is inflexible. It commits the class to creating a particular 
	representation of the complex object and makes it impossible to change the representation later independently from (without having to change) 
	the class.
	The Builder design pattern describes how to solve such problems:
	Encapsulate creating and assembling the parts of a complex object in a separate Builder object.
	A class delegates object creation to a Builder object instead of creating the objects directly.
	A class (the same construction process) can delegate to different Builder objects to create different representations of a complex object.

The Prototype Pattern
	A creational design pattern in software development. It is used when the type of objects to create is determined by a prototypical instance, 
	which is cloned to produce new objects. This pattern is used to:
	avoid subclasses of an object creator in the client application, like the factory method pattern does.
	avoid the inherent cost of creating a new object in the standard way (e.g., using the 'new' keyword) when it is prohibitively expensive 
	for a given application.
	To implement the pattern, declare an abstract base class that specifies a pure virtual clone() method. Any class that needs a "polymorphic 
	constructor" capability derives itself from the abstract base class, and implements the clone() operation.
	The client, instead of writing code that invokes the "new" operator on a hard-coded class name, calls the clone() method on the prototype, 
	calls a factory method with a parameter designating the particular concrete derived class desired, or invokes the clone() method through 
	some mechanism provided by another design pattern.
	The mitotic division of a cell — resulting in two identical cells — is an example of a prototype that plays an active role in copying itself 
	and thus, demonstrates the Prototype pattern. When a cell splits, two cells of identical genotype result. In other words, the cell clones 
	itself.

Bridge Pattern
	A design pattern used in software engineering that is meant to "decouple an abstraction from its implementation so that the two can vary 
	independently", introduced by the Gang of Four. The bridge uses encapsulation, aggregation, and can use inheritance to separate responsibilities 
	into different classes.
	When a class varies often, the features of object-oriented programming become very useful because changes to a program's code can be made 
	easily with minimal prior knowledge about the program. The bridge pattern is useful when both the class and what it does vary often. The 
	class itself can be thought of as the abstraction and what the class can do as the implementation. The bridge pattern can also be thought 
	of as two layers of abstraction.

Decorator Design Pattern
	A design pattern that allows behavior to be added to an individual object, dynamically, without affecting the behavior of other objects from 
	the same class. The decorator pattern is often useful for adhering to the Single Responsibility Principle, as it allows functionality to 
	be divided between classes with unique areas of concern. The decorator pattern is structurally nearly identical to the chain of responsibility 
	pattern, the difference being that in a chain of responsibility, exactly one of the classes handles the request, while for the decorator, all 
	classes handle the request.

Flyweight
	Is a software design pattern. A flyweight is an object that minimizes memory usage by sharing as much data as possible with other similar 
	objects; it is a way to use objects in large numbers when a simple repeated representation would use an unacceptable amount of memory. Often 
	some parts of the object state can be shared, and it is common practice to hold them in external data structures and pass them to the objects 
	temporarily when they are used.
	A classic example usage of the flyweight pattern is the data structures for graphical representation of characters in a word processor. 
	It might be desirable to have, for each character in a document, a glyph object containing its font outline, font metrics, and other formatting 
	data, but this would amount to hundreds or thousands of bytes for each character. Instead, for every character there might be a reference to 
	a flyweight glyph object shared by every instance of the same character in the document; only the position of each character (in the document 
	and/or the page) would need to be stored internally.
	Another example is string interning. In other contexts the idea of sharing identical data structures is called hash consing.

Chain of Responsibility
	Is a design pattern consisting of a source of command objects and a series of processing objects. Each processing object contains logic that 
	defines the types of command objects that it can handle; the rest are passed to the next processing object in the chain. A mechanism also 
	exists for adding new processing objects to the end of this chain. Thus, the chain of responsibility is an object oriented version of the 
	if ... else if ... else if ....... else ... endif idiom, with the benefit that the condition–action blocks can be dynamically rearranged and 
	reconfigured at runtime.
	In a variation of the standard chain-of-responsibility model, some handlers may act as dispatchers, capable of sending commands out in a variety 
	of directions, forming a tree of responsibility. In some cases, this can occur recursively, with processing objects calling higher-up processing 
	objects with commands that attempt to solve some smaller part of the problem; in this case recursion continues until the command is processed, 
	or the entire tree has been explored. An XML interpreter might work in this manner.
	This pattern promotes the idea of loose coupling.
	The chain-of-responsibility pattern is structurally nearly identical to the decorator pattern, the difference being that for the decorator, all 
	classes handle the request, while for the chain of responsibility, exactly one of the classes in the chain handles the request. 
	What solution does the Chain of Responsibility design pattern describe?
	Define a chain of receiver objects having the responsibility, depending on run-time conditions, to either handle a request or forward it to the 
	next receiver on the chain (if any).
	This enables to send a request to a chain of receivers without having to know which one handles the request. The request gets passed along the 
	chain until a receiver handles the request. The sender of a request is no longer coupled to a particular receiver.

Interpreter Pattern
	A design pattern that specifies how to evaluate sentences in a language. The basic idea is to have a class for each symbol (terminal or 
	nonterminal) in a specialized computer language. The syntax tree of a sentence in the language is an instance of the composite pattern and 
	is used to evaluate (interpret) the sentence for a client.

Iterator Pattern
	

Mediator Pattern
	

Memento
	

State Pattern
	

Template Method
	

Visitor Pattern
	

Most often used design patterns:

Repository
	A Repository in C# mediates between the domain and data mapping layers (like Entity Framework). It allows you to pull a record or number of 
	records out of datasets, and then have those records to work on acting like an in-memory domain object collection, and you can also update 
	or delete records within those data set, and the mapping code encapsulated by the Repository will carry out the appropriate operations behind 
	the scenes.
	Repository pattern C# is a way to implement data access by encapsulating the set of objects persisted in a data store and the operations 
	performed over them, providing a more object-oriented view of the persistence layer.
	Repository pattern C# also supports the objective of achieving a clean separation and one-way dependency between the domain and data mapping 
	layers.
	Repository pattern C# is mostly used where we need to modify the data before passing to the next stage.

Service Locator Pattern
	The service locator pattern is a design pattern used in software development to encapsulate the processes involved in obtaining a service 
	with a strong abstraction layer. This pattern uses a central registry known as the “service locator” which on request returns the information 
	necessary to perform a certain task.
	The ServiceLocator is responsible for returning instances of services when they are requested for by the service consumers or the service 
	clients.

Unit of Work
	Maintains a list of objects affected by a business transaction and coordinates the writing out of changes.  
	Increases the level of abstraction and keep business logic free of data access code
	Increased maintainability, flexibility and testability
	More classes and interfaces but less duplicated code
	The business logic is further away from the data because the repository abstracts the infrastructure. This has the effect that it might be 
	harder to optimize certain operations which are performed against the data source.

Rules Pattern
	The Rules Pattern works by separating out the rules from the rules processing logic (applying the Single Responsibility Principle). This 
	makes it easy to add new rules without changing the rest of the system (applying the Open/Closed Principle).
	With the Rules Pattern there is an Evaluator class that loops through a collection of rules and executes them. It evaluates the result 
	and decides what action to take. In the simplest case it just executes all the rules, but it is also possible to add some selection logic 
	to each rule that allows the Evaluator class to decide whether or not to run the rule (such as the IsMatch() method on the IRule interface 
	above).

Specification Pattern
	

Event Aggregator
	

Lazy Load Pattern


Model View Presenter (MVP) Pattern


Model View ViewModel (MVVM) Pattern


Null Object Pattern


Software Architecture Patterns (structure, pros & cons): 

Layered architecture


Event-driven architecture


Microkernel architecture


Microservices architecture


Inversion of Control Containers and the Dependency Injection pattern


Domain-Driven Design patterns:

Why Should You Care About Domain-Driven Design?


Benefits of DDD


Drawbacks of DDD


A Mind Map of DDD's Working Parts



Sub-domain


Bounded Context


Difference Between Sub-domain and Bounded Context


Understanding Context Maps


The Ubiquitous Language of a Bounded Context




Anemic and Rich Models


Entities in DDD and in Our Bounded Context


Value Objects


Domain Services


Aggregates and Aggregate Roots


Repositories


Domain Events


Anti-patterns


