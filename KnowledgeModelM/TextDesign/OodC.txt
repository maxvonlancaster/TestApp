SOLID
	is a mnemonic acronym for five design principles intended to make software designs more understandable, flexible and maintainable.
	Single responsibility principle: A class should only have a single responsibility, that is, only changes to one part of the software's 
	specification should be able to affect the specification of the class.
	Open–closed principle: Software entities ... should be open for extension, but closed for modification.
	Liskov substitution principle: Objects in a program should be replaceable with instances of their subtypes without altering the correctness 
	of that program. See also design by contract.
	Interface segregation principle: Many client-specific interfaces are better than one general-purpose interface.
	Dependency inversion principle: One should "depend upon abstractions, [not] concretions."

GoF Design Patterns

Good understanding is required:

Factory Patterns
	

Singleton
	A software design pattern that restricts the instantiation of a class to one "single" instance. This is useful when exactly one object is 
	needed to coordinate actions across the system. The term comes from the mathematical concept of a singleton. The singleton design pattern 
	describes how to solve such problems: Hide the constructor of the class; Define a public static operation (getInstance()) that returns the 
	sole instance of the class. The key idea in this pattern is to make the class itself responsible for controlling its instantiation (that it 
	is instantiated only once). The hidden constructor (declared private) ensures that the class can never be instantiated from outside the class.
	The public static operation can be accessed easily by using the class name and operation name (Singleton.getInstance()).

Adapter Pattern
	A software design pattern (also known as wrapper, an alternative naming shared with the decorator pattern) that allows the interface of an 
	existing class to be used as another interface. It is often used to make existing classes work with others without modifying their source 
	code.
	The adapter design pattern solves problems like: How can a class be reused that does not have an interface that a client requires?; How can 
	classes that have incompatible interfaces work together?; How can an alternative interface be provided for a class?; 
	Often an (already existing) class can't be reused only because its interface doesn't conform to the interface clients require.
	The adapter design pattern describes how to solve such problems: Define a separate adapter class that converts the (incompatible) interface
	of a class (adaptee) into another interface (target) clients require. Work through an adapter to work with (reuse) classes that do not have 
	the required interface. The key idea in this pattern is to work through a separate adapter that adapts the interface of an (already existing) 
	class without changing it.
	Clients don't know whether they work with a target class directly or through an adapter with a class that does not have the target interface.

Composite Pattern
	Is a partitioning design pattern. The composite pattern describes a group of objects that are treated the same way as a single instance of the 
	same type of object. The intent of a composite is to "compose" objects into tree structures to represent part-whole hierarchies. Implementing 
	the composite pattern lets clients treat individual objects and compositions uniformly.
	What problems can the Composite design pattern solve?: A part-whole hierarchy should be represented so that clients can treat part and whole 
	objects uniformly; A part-whole hierarchy should be represented as tree structure; When defining Part objects and Whole objects that act as 
	containers for Part objects, clients must treat them separately, which complicates client code.
	What solution does the Composite design pattern describe? Define a unified Component interface for both part (Leaf) objects and whole (Composite) 
	objects; Individual Leaf objects implement the Component interface directly, and Composite objects forward requests to their child components.
	This enables clients to work through the Component interface to treat Leaf and Composite objects uniformly: Leaf objects perform a request 
	directly, and Composite objects forward the request to their child components recursively downwards the tree structure. This makes client 
	classes easier to implement, change, test, and reuse.

Facade Pattern
	A software-design pattern commonly used in object-oriented programming. Analogous to a facade in architecture, a facade is an object that serves 
	as a front-facing interface masking more complex underlying or structural code. A facade can: improve the readability and usability of a software 
	library by masking interaction with more complex components behind a single (and often simplified) API; provide a context-specific interface to 
	more generic functionality (complete with context-specific input validation); serve as a launching point for a broader refactor of monolithic 
	or tightly-coupled systems in favor of more loosely-coupled code
	Developers often use the facade design pattern when a system is very complex or difficult to understand because the system has many interdependent 
	classes or because its source code is unavailable. This pattern hides the complexities of the larger system and provides a simpler interface to 
	the client. It typically involves a single wrapper class that contains a set of members required by the client. These members access the system 
	on behalf of the facade client and hide the implementation details.
	Define a Facade object that: implements a simple interface in terms of (by delegating to) the interfaces in the subsystem and may perform 
	additional functionality before/after forwarding a request. This enables to work through a Facade object to minimize the dependencies on a 
	subsystem.

Proxy Pattern
	

The Command Pattern
	

Observer Pattern
	

Strategy Pattern
	

High-level understanding is required:

The Builder Pattern
	

The Prototype Pattern
	

Bridge Pattern
	

Decorator Design Pattern
	

Flyweight
	Is a software design pattern. A flyweight is an object that minimizes memory usage by sharing as much data as possible with other similar 
	objects; it is a way to use objects in large numbers when a simple repeated representation would use an unacceptable amount of memory. Often 
	some parts of the object state can be shared, and it is common practice to hold them in external data structures and pass them to the objects 
	temporarily when they are used.
	A classic example usage of the flyweight pattern is the data structures for graphical representation of characters in a word processor. 
	It might be desirable to have, for each character in a document, a glyph object containing its font outline, font metrics, and other formatting 
	data, but this would amount to hundreds or thousands of bytes for each character. Instead, for every character there might be a reference to 
	a flyweight glyph object shared by every instance of the same character in the document; only the position of each character (in the document 
	and/or the page) would need to be stored internally.
	Another example is string interning. In other contexts the idea of sharing identical data structures is called hash consing.

Chain of Responsibility
	Is a design pattern consisting of a source of command objects and a series of processing objects. Each processing object contains logic that 
	defines the types of command objects that it can handle; the rest are passed to the next processing object in the chain. A mechanism also 
	exists for adding new processing objects to the end of this chain. Thus, the chain of responsibility is an object oriented version of the 
	if ... else if ... else if ....... else ... endif idiom, with the benefit that the condition–action blocks can be dynamically rearranged and 
	reconfigured at runtime.
	In a variation of the standard chain-of-responsibility model, some handlers may act as dispatchers, capable of sending commands out in a variety 
	of directions, forming a tree of responsibility. In some cases, this can occur recursively, with processing objects calling higher-up processing 
	objects with commands that attempt to solve some smaller part of the problem; in this case recursion continues until the command is processed, 
	or the entire tree has been explored. An XML interpreter might work in this manner.
	This pattern promotes the idea of loose coupling.
	The chain-of-responsibility pattern is structurally nearly identical to the decorator pattern, the difference being that for the decorator, all 
	classes handle the request, while for the chain of responsibility, exactly one of the classes in the chain handles the request. 
	What solution does the Chain of Responsibility design pattern describe?
	Define a chain of receiver objects having the responsibility, depending on run-time conditions, to either handle a request or forward it to the 
	next receiver on the chain (if any).
	This enables to send a request to a chain of receivers without having to know which one handles the request. The request gets passed along the 
	chain until a receiver handles the request. The sender of a request is no longer coupled to a particular receiver.

Interpreter Pattern
	

Iterator Pattern
	

Mediator Pattern
	

Memento
	

State Pattern
	

Template Method
	

Visitor Pattern
	

Most often used design patterns:

Repository
	A Repository in C# mediates between the domain and data mapping layers (like Entity Framework). It allows you to pull a record or number of 
	records out of datasets, and then have those records to work on acting like an in-memory domain object collection, and you can also update 
	or delete records within those data set, and the mapping code encapsulated by the Repository will carry out the appropriate operations behind 
	the scenes.
	Repository pattern C# is a way to implement data access by encapsulating the set of objects persisted in a data store and the operations 
	performed over them, providing a more object-oriented view of the persistence layer.
	Repository pattern C# also supports the objective of achieving a clean separation and one-way dependency between the domain and data mapping 
	layers.
	Repository pattern C# is mostly used where we need to modify the data before passing to the next stage.

Service Locator Pattern
	The service locator pattern is a design pattern used in software development to encapsulate the processes involved in obtaining a service 
	with a strong abstraction layer. This pattern uses a central registry known as the “service locator” which on request returns the information 
	necessary to perform a certain task.
	The ServiceLocator is responsible for returning instances of services when they are requested for by the service consumers or the service 
	clients.

Unit of Work
	Maintains a list of objects affected by a business transaction and coordinates the writing out of changes.  
	Increases the level of abstraction and keep business logic free of data access code
	Increased maintainability, flexibility and testability
	More classes and interfaces but less duplicated code
	The business logic is further away from the data because the repository abstracts the infrastructure. This has the effect that it might be 
	harder to optimize certain operations which are performed against the data source.

Rules Pattern


Specification Pattern


Event Aggregator


Lazy Load Pattern


Model View Presenter (MVP) Pattern


Model View ViewModel (MVVM) Pattern


Null Object Pattern


Software Architecture Patterns (structure, pros & cons): 

Layered architecture


Event-driven architecture


Microkernel architecture


Microservices architecture


Inversion of Control Containers and the Dependency Injection pattern


Domain-Driven Design patterns:

Why Should You Care About Domain-Driven Design?


Benefits of DDD


Drawbacks of DDD


A Mind Map of DDD's Working Parts



Sub-domain


Bounded Context


Difference Between Sub-domain and Bounded Context


Understanding Context Maps


The Ubiquitous Language of a Bounded Context




Anemic and Rich Models


Entities in DDD and in Our Bounded Context


Value Objects


Domain Services


Aggregates and Aggregate Roots


Repositories


Domain Events


Anti-patterns


