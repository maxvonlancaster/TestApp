SOLID
	is a mnemonic acronym for five design principles intended to make software designs more understandable, flexible and maintainable.
	Single responsibility principle: A class should only have a single responsibility, that is, only changes to one part of the software's 
	specification should be able to affect the specification of the class.
	Open–closed principle: Software entities ... should be open for extension, but closed for modification.
	Liskov substitution principle: Objects in a program should be replaceable with instances of their subtypes without altering the correctness 
	of that program. See also design by contract.
	Interface segregation principle: Many client-specific interfaces are better than one general-purpose interface.
	Dependency inversion principle: One should "depend upon abstractions, [not] concretions."

GoF Design Patterns
	

Good understanding is required:

Factory Patterns

Singleton
	

Adapter Pattern
	

Composite Pattern
	

Facade Pattern
	

Proxy Pattern
	

The Command Pattern
	

Observer Pattern
	

Strategy Pattern
	

High-level understanding is required:

The Builder Pattern
	

The Prototype Pattern
	

Bridge Pattern
	

Decorator Design Pattern
	

Flyweight
	

Chain of Responsibility
	

Interpreter Pattern
	

Iterator Pattern
	

Mediator Pattern
	

Memento
	

State Pattern
	

Template Method
	

Visitor Pattern
	

Most often used design patterns:

Repository


Service Locator Pattern


Unit of Work


Rules Pattern


Specification Pattern


Event Aggregator


Lazy Load Pattern


Model View Presenter (MVP) Pattern


Model View ViewModel (MVVM) Pattern


Null Object Pattern


Software Architecture Patterns (structure, pros & cons): 

Layered architecture


Event-driven architecture


Microkernel architecture


Microservices architecture


Inversion of Control Containers and the Dependency Injection pattern


Domain-Driven Design patterns:

Why Should You Care About Domain-Driven Design?


Benefits of DDD


Drawbacks of DDD


A Mind Map of DDD's Working Parts



Sub-domain


Bounded Context


Difference Between Sub-domain and Bounded Context


Understanding Context Maps


The Ubiquitous Language of a Bounded Context




Anemic and Rich Models


Entities in DDD and in Our Bounded Context


Value Objects


Domain Services


Aggregates and Aggregate Roots


Repositories


Domain Events


Anti-patterns


